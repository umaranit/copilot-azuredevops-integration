# Azure DevOps Pipeline for AI-Powered Backlog Analysis
# Uses GitHub Copilot CLI to analyze work items and provide quality insights

trigger: none  # Manual trigger - can be changed to scheduled

pool:
  vmImage: 'ubuntu-latest'

parameters:
  - name: analyzeTop
    displayName: 'Number of work items to analyze'
    type: number
    default: 5
    values: [5, 10, 15, 20, 25, 30]
  
  - name: analysisMode
    displayName: 'Analysis Mode'
    type: string
    default: 'standard'
    values: 
      - 'basic'      # Quick quality check
      - 'standard'   # Full INVEST analysis
      - 'detailed'   # Comprehensive with recommendations
      - 'governance' # Compliance and risk assessment
  
  - name: workItemTypes
    displayName: 'Work Item Types to Analyze'
    type: string
    default: 'User Story,Product Backlog Item'
  
  - name: projectName
    displayName: 'Azure DevOps Project Name'
    type: string
    default: 'Parts Unlimited'
  
  - name: includeClosedItems
    displayName: 'Include Recently Closed Items'
    type: boolean
    default: false
  
  - name: priorityFilter
    displayName: 'Priority Filter (1=High, 4=Low)'
    type: string
    default: '1,2,3,4'
  
  - name: enableNotifications
    displayName: 'Enable Teams/Slack Notifications'
    type: boolean
    default: false
  
  - name: generateExecutiveSummary
    displayName: 'Generate Executive Summary'
    type: boolean
    default: true

variables:
  # Security: Variable groups for credentials
  - group: 'copilot-credentials'  # Required: GITHUB_TOKEN
  - group: 'notification-settings'  # Optional: TEAMS_WEBHOOK, SLACK_WEBHOOK
  
  # Pipeline Configuration
  - name: PROJECT_NAME_ENCODED
    value: ${{ replace(parameters.projectName, ' ', '%20') }}
  - name: ANALYSIS_TIMESTAMP
    value: $[format('{0:yyyy}-{0:MM}-{0:dd}T{0:HH}-{0:mm}-{0:ss}Z', pipeline.startTime)]
  - name: COPILOT_CLI_VERSION
    value: '@github/copilot@latest'
  - name: NODE_VERSION
    value: '22'
  - name: MAX_RETRY_ATTEMPTS
    value: 3
  - name: COPILOT_TIMEOUT
    value: 120  # seconds
  - name: API_TIMEOUT
    value: 30   # seconds

stages:
- stage: Setup
  displayName: 'Setup Environment & Validation'
  jobs:
  - job: ValidatePrerequisites
    displayName: 'Validate Prerequisites'
    timeoutInMinutes: 10
    steps:
    
    - script: |
        echo "üîç VALIDATING PIPELINE PARAMETERS"
        echo "======================================"
        echo "Analysis Mode: ${{ parameters.analysisMode }}"
        echo "Items to Analyze: ${{ parameters.analyzeTop }}"
        echo "Project: ${{ parameters.projectName }}"
        echo "Work Item Types: ${{ parameters.workItemTypes }}"
        echo "Include Closed: ${{ parameters.includeClosedItems }}"
        echo "Priority Filter: ${{ parameters.priorityFilter }}"
        echo "Notifications: ${{ parameters.enableNotifications }}"
        echo "Executive Summary: ${{ parameters.generateExecutiveSummary }}"
        echo "Timestamp: $(ANALYSIS_TIMESTAMP)"
        
        # Validate parameter ranges
        if [ ${{ parameters.analyzeTop }} -lt 1 ] || [ ${{ parameters.analyzeTop }} -gt 30 ]; then
          echo "‚ùå ERROR: analyzeTop must be between 1 and 30"
          exit 1
        fi
        
        # Validate priority filter format
        if ! echo "${{ parameters.priorityFilter }}" | grep -E '^[1-4](,[1-4])*$' > /dev/null; then
          echo "‚ùå ERROR: Invalid priority filter format. Use comma-separated values 1-4"
          exit 1
        fi
        
        echo "‚úÖ Parameter validation passed"
        
      displayName: 'Validate Parameters'
    
    - script: |
        echo "üõ†Ô∏è INSTALLING PREREQUISITES WITH RETRY LOGIC"
        echo "============================================="
        
        # Function for retries
        retry_command() {
          local cmd="$1"
          local max_attempts=$(MAX_RETRY_ATTEMPTS)
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt/$max_attempts: $cmd"
            if eval "$cmd"; then
              echo "‚úÖ Command succeeded on attempt $attempt"
              return 0
            else
              echo "‚ùå Command failed on attempt $attempt"
              if [ $attempt -eq $max_attempts ]; then
                echo "üí• All attempts failed!"
                return 1
              fi
              echo "‚è≥ Waiting 5 seconds before retry..."
              sleep 5
              attempt=$((attempt + 1))
            fi
          done
        }
        
        # Install Node.js with retry
        retry_command "curl -fsSL https://deb.nodesource.com/setup_$(NODE_VERSION).x | sudo -E bash -"
        retry_command "sudo apt-get update && sudo apt-get install -y nodejs jq curl"
        
        # Verify installations
        echo "üìã VERIFYING INSTALLATIONS"
        echo "Node.js version: $(node --version)"
        echo "npm version: $(npm --version)"
        echo "jq version: $(jq --version)"
        
        # Validate Node.js version
        NODE_MAJOR=$(node --version | cut -d'.' -f1 | sed 's/v//')
        if [ "$NODE_MAJOR" -lt $(NODE_VERSION) ]; then
          echo "‚ùå ERROR: Node.js version must be $(NODE_VERSION) or higher"
          exit 1
        fi
        
        echo "‚úÖ Prerequisites validated successfully"
        
      displayName: 'Install and Validate Tools'
    
    - script: |
        echo "üöÄ INSTALLING GITHUB COPILOT CLI"
        echo "================================"
        
        # Install with retry and version verification
        retry_command() {
          local max_attempts=$(MAX_RETRY_ATTEMPTS)
          local attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Installing Copilot CLI (attempt $attempt/$max_attempts)..."
            if sudo npm install -g $(COPILOT_CLI_VERSION) --timeout=60000; then
              echo "‚úÖ Copilot CLI installed successfully"
              return 0
            else
              echo "‚ùå Installation failed on attempt $attempt"
              if [ $attempt -eq $max_attempts ]; then
                echo "üí• Copilot CLI installation failed after $max_attempts attempts"
                return 1
              fi
              sleep 10
              attempt=$((attempt + 1))
            fi
          done
        }
        
        retry_command
        
        # Verify installation
        echo "üìã VERIFYING COPILOT CLI"
        which copilot || {
          echo "‚ùå ERROR: Copilot CLI not found in PATH"
          exit 1
        }
        
        # Test basic functionality
        copilot --version 2>/dev/null || echo "Copilot CLI ready (version check skipped)"
        
        echo "‚úÖ GitHub Copilot CLI ready"
        
      displayName: 'Install GitHub Copilot CLI'
    
    - script: |
        echo "üîê TESTING COPILOT CLI AUTHENTICATION"
        echo "===================================="
        
        # Set environment variables for authentication
        export GITHUB_TOKEN="$(GITHUB_TOKEN)"
        export GH_TOKEN="$(GITHUB_TOKEN)"
        
        # Enhanced token validation
        if [ -z "$GITHUB_TOKEN" ]; then
          echo "‚ùå CRITICAL ERROR: GITHUB_TOKEN is not set!"
          echo "üí° Solution: Create variable group 'copilot-credentials' with GITHUB_TOKEN"
          exit 1
        fi
        
        # Validate token format (GitHub tokens start with ghp_, gho_, ghu_, or ghs_)
        if ! echo "$GITHUB_TOKEN" | grep -E '^gh[pousr]_[A-Za-z0-9_]{36,}$' > /dev/null; then
          echo "‚ùå WARNING: GITHUB_TOKEN format may be invalid"
          echo "Expected format: ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
        fi
        
        echo "‚úÖ GITHUB_TOKEN is set (length: ${#GITHUB_TOKEN})"
        
        # Multi-stage authentication test
        test_copilot() {
          local test_prompt="$1"
          local timeout_duration="$2"
          local attempt="$3"
          
          echo "üß™ Test $attempt: $test_prompt"
          
          local result
          result=$(echo "$test_prompt" | timeout "$timeout_duration" copilot 2>&1)
          local exit_code=$?
          
          case $exit_code in
            0)
              echo "‚úÖ Test $attempt passed"
              return 0
              ;;
            124)
              echo "‚è±Ô∏è Test $attempt timed out after ${timeout_duration}s"
              return 1
              ;;
            *)
              echo "‚ùå Test $attempt failed (exit code: $exit_code)"
              echo "Response: $result"
              return 1
              ;;
          esac
        }
        
        # Progressive authentication tests
        echo "üîç Running progressive authentication tests..."
        
        # Test 1: Simple math (fast response expected)
        if test_copilot "What is 2+2? Answer with just the number." 15 1; then
          echo "‚úÖ Basic Copilot functionality confirmed"
        else
          echo "‚ùå Basic test failed, trying alternative approach..."
          
          # Test 2: Even simpler prompt
          if test_copilot "Say 'OK'" 10 2; then
            echo "‚úÖ Alternative test passed"
          else
            echo "‚ùå CRITICAL: All Copilot authentication tests failed!"
            echo "üí° Troubleshooting steps:"
            echo "   1. Verify GITHUB_TOKEN has Copilot access"
            echo "   2. Check if Copilot subscription is active"
            echo "   3. Ensure token has required scopes"
            exit 1
          fi
        fi
        
        # Test 3: Verify Copilot can handle structured prompts
        echo "üîç Testing structured prompt handling..."
        if test_copilot "Analyze this text and respond with 'READY': Hello World" 20 3; then
          echo "‚úÖ Structured prompt test passed"
        else
          echo "‚ö†Ô∏è WARNING: Structured prompts may have issues"
          echo "Continuing with basic functionality..."
        fi
        
        echo "üéâ Copilot CLI authentication and functionality verified!"
        
      displayName: 'Test Copilot Authentication & Functionality'
      env:
        GITHUB_TOKEN: $(GITHUB_TOKEN)
        GH_TOKEN: $(GITHUB_TOKEN)
      timeoutInMinutes: 5

- stage: FetchWorkItems
  displayName: 'Fetch Work Items from Azure DevOps'
  dependsOn: Setup
  condition: succeeded()
  jobs:
  - job: GetWorkItems
    displayName: 'Query and Fetch Work Items'
    timeoutInMinutes: 15
    steps:
    
    - script: |
        echo "üìã BUILDING DYNAMIC WIQL QUERY"
        echo "=============================="
        
        # Build state filter based on includeClosedItems parameter
        if [ "${{ parameters.includeClosedItems }}" = "true" ]; then
          STATE_FILTER="AND [System.State] NOT IN ('Removed')"
          echo "üìä Including closed items in analysis"
        else
          STATE_FILTER="AND [System.State] NOT IN ('Closed', 'Done', 'Removed', 'Resolved')"
          echo "üìä Excluding closed items from analysis"
        fi
        
        # Build priority filter
        PRIORITY_VALUES=$(echo "${{ parameters.priorityFilter }}" | sed 's/,/", "/g')
        PRIORITY_FILTER="AND [Microsoft.VSTS.Common.Priority] IN (\"$PRIORITY_VALUES\")"
        
        # Build work item type filter
        WIT_VALUES=$(echo "${{ parameters.workItemTypes }}" | sed 's/,/", "/g')
        WIT_FILTER="AND [System.WorkItemType] IN (\"$WIT_VALUES\")"
        
        echo "Priority Filter: $PRIORITY_FILTER"
        echo "Work Item Types: $WIT_FILTER"
        echo "State Filter: $STATE_FILTER"
        
        # Create comprehensive WIQL query using echo instead of heredoc
        echo "{" > query.json
        echo "  \"query\": \"SELECT [System.Id], [System.Title], [System.WorkItemType], [System.State], [System.Description], [Microsoft.VSTS.Common.AcceptanceCriteria], [Microsoft.VSTS.Common.Priority], [Microsoft.VSTS.Scheduling.StoryPoints], [System.Tags], [System.AreaPath], [System.IterationPath], [System.CreatedDate], [System.ChangedDate], [System.AssignedTo] FROM WorkItems WHERE [System.TeamProject] = '${{ parameters.projectName }}' $WIT_FILTER $STATE_FILTER $PRIORITY_FILTER ORDER BY [Microsoft.VSTS.Common.Priority], [System.ChangedDate] DESC\"" >> query.json
        echo "}" >> query.json
        
        echo "üìã Generated WIQL Query:"
        cat query.json | jq .
        
      displayName: 'Generate Dynamic WIQL Query'
    
    - script: |
        echo "üöÄ EXECUTING AZURE DEVOPS API CALLS"
        echo "===================================="
        
        # Function for API calls with retry logic
        call_api_with_retry() {
          local url="$1"
          local method="$2"
          local data="$3"
          local output_file="$4"
          local description="$5"
          local max_attempts=$(MAX_RETRY_ATTEMPTS)
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "üìû Attempt $attempt/$max_attempts: $description"
            
            local curl_cmd
            if [ "$method" = "POST" ]; then
              curl_cmd="curl -s -X POST -H 'Authorization: Bearer $(System.AccessToken)' -H 'Content-Type: application/json' -d @$data --connect-timeout $(API_TIMEOUT) --max-time $(API_TIMEOUT) '$url'"
            else
              curl_cmd="curl -s -H 'Authorization: Bearer $(System.AccessToken)' --connect-timeout $(API_TIMEOUT) --max-time $(API_TIMEOUT) '$url'"
            fi
            
            if eval "$curl_cmd" > "$output_file.tmp"; then
              # Validate JSON response
              if jq empty "$output_file.tmp" 2>/dev/null; then
                mv "$output_file.tmp" "$output_file"
                echo "‚úÖ $description successful"
                return 0
              else
                echo "‚ùå Invalid JSON response on attempt $attempt"
                cat "$output_file.tmp" | head -5
              fi
            else
              echo "‚ùå API call failed on attempt $attempt"
            fi
            
            if [ $attempt -eq $max_attempts ]; then
              echo "üí• $description failed after $max_attempts attempts"
              return 1
            fi
            
            echo "‚è≥ Waiting 10 seconds before retry..."
            sleep 10
            attempt=$((attempt + 1))
          done
        }
        
        # Execute WIQL query with retry
        API_URL="$(System.CollectionUri)$(PROJECT_NAME_ENCODED)/_apis/wit/wiql?api-version=7.0"
        
        if ! call_api_with_retry "$API_URL" "POST" "query.json" "workitem_ids.json" "WIQL Query Execution"; then
          echo "‚ùå CRITICAL: Failed to execute WIQL query"
          exit 1
        fi
        
        # Validate query results
        TOTAL_ITEMS=$(cat workitem_ids.json | jq '.workItems | length')
        echo "üìã Query returned $TOTAL_ITEMS work items"
        
        if [ "$TOTAL_ITEMS" -eq 0 ]; then
          echo "‚ö†Ô∏è WARNING: No work items found matching criteria"
          echo "üí° Check your filters:"
          echo "   - Project: ${{ parameters.projectName }}"
          echo "   - Work Item Types: ${{ parameters.workItemTypes }}"
          echo "   - Priority Filter: ${{ parameters.priorityFilter }}"
          echo "   - Include Closed: ${{ parameters.includeClosedItems }}"
          
          # Create empty result for downstream stages
          echo '{"value": []}' > workitems_detailed.json
        else
          # Get limited set of IDs based on analyzeTop parameter
          ITEMS_TO_FETCH=$([ "$TOTAL_ITEMS" -lt ${{ parameters.analyzeTop }} ] && echo "$TOTAL_ITEMS" || echo "${{ parameters.analyzeTop }}")
          echo "üéØ Fetching top $ITEMS_TO_FETCH items for analysis"
          
          IDS=$(cat workitem_ids.json | jq -r ".workItems[:$ITEMS_TO_FETCH] | map(.id) | join(\",\")")
          
          if [ -n "$IDS" ]; then
            echo "üìé Work Item IDs to fetch: $IDS"
            
            # Fetch detailed work items with retry
            DETAILS_URL="$(System.CollectionUri)$(PROJECT_NAME_ENCODED)/_apis/wit/workitems?ids=${IDS}&\$expand=all&api-version=7.0"
            
            if call_api_with_retry "$DETAILS_URL" "GET" "" "workitems_detailed.json" "Work Items Details Fetch"; then
              # Validate and summarize results
              FETCHED_COUNT=$(cat workitems_detailed.json | jq '.value | length')
              echo ""
              echo "üéâ SUCCESSFULLY FETCHED $FETCHED_COUNT WORK ITEMS"
              echo "================================================"
              
              # Display summary
              cat workitems_detailed.json | jq -r '.value[] | "ID: \(.id) | Type: \(.fields."System.WorkItemType") | Title: \(.fields."System.Title" // "No Title")"' | head -10
              
              if [ "$FETCHED_COUNT" -gt 10 ]; then
                echo "... and $((FETCHED_COUNT - 10)) more items"
              fi
            else
              echo "‚ùå CRITICAL: Failed to fetch work item details"
              exit 1
            fi
          else
            echo "‚ùå ERROR: No valid work item IDs extracted"
            exit 1
          fi
        fi
        
        # Save artifacts
        mkdir -p $(Agent.TempDirectory)/workitems-data
        cp workitems_detailed.json $(Agent.TempDirectory)/workitems-data/
        cp workitem_ids.json $(Agent.TempDirectory)/workitems-data/
        
        # Create metadata file using echo instead of heredoc
        echo "{" > $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "  \"pipeline_run\": \"$(Build.BuildId)\"," >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "  \"timestamp\": \"$(ANALYSIS_TIMESTAMP)\"," >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "  \"project\": \"${{ parameters.projectName }}\"," >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "  \"total_available\": $TOTAL_ITEMS," >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "  \"items_fetched\": $(cat workitems_detailed.json | jq '.value | length')," >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "  \"analysis_mode\": \"${{ parameters.analysisMode }}\"," >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "  \"parameters\": {" >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "    \"analyzeTop\": ${{ parameters.analyzeTop }}," >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "    \"workItemTypes\": \"${{ parameters.workItemTypes }}\"," >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "    \"includeClosedItems\": ${{ parameters.includeClosedItems }}," >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "    \"priorityFilter\": \"${{ parameters.priorityFilter }}\"" >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "  }" >> $(Agent.TempDirectory)/workitems-data/metadata.json
        echo "}" >> $(Agent.TempDirectory)/workitems-data/metadata.json
        
        echo "‚úÖ Work items data prepared for analysis"
        
      displayName: 'Fetch Work Items with Retry Logic'
      env:
        SYSTEM_ACCESSTOKEN: $(System.AccessToken)
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Work Items Data'
      inputs:
        pathToPublish: '$(Agent.TempDirectory)/workitems-data'
        artifactName: 'workitems-data'
      condition: always()

- stage: AnalyzeWithCopilot
  displayName: 'AI Analysis with GitHub Copilot'
  dependsOn: 
    - Setup
    - FetchWorkItems
  condition: succeeded()
  jobs:
  - job: CopilotAnalysis
    displayName: 'Advanced Copilot Analysis'
    timeoutInMinutes: 30
    steps:
    
    - script: |
        # Reinstall Copilot CLI in this job (different agent)
        curl -fsSL https://deb.nodesource.com/setup_$(NODE_VERSION).x | sudo -E bash -
        sudo apt-get install -y nodejs jq
        sudo npm install -g $(COPILOT_CLI_VERSION) --timeout=60000
        
        echo "‚úÖ Copilot CLI ready for analysis"
        
      displayName: 'Setup Copilot CLI for Analysis'
    
    - task: DownloadBuildArtifacts@0
      displayName: 'Download Work Items Data'
      inputs:
        artifactName: 'workitems-data'
        downloadPath: '$(Agent.TempDirectory)'
    
    - script: |
        # Set authentication tokens
        export GITHUB_TOKEN="$(GITHUB_TOKEN)"
        export GH_TOKEN="$(GITHUB_TOKEN)"
        
        echo "ü§ñ STARTING ADVANCED COPILOT ANALYSIS"
        echo "====================================="
        
        # Load metadata
        METADATA_FILE="$(Agent.TempDirectory)/workitems-data/metadata.json"
        if [ -f "$METADATA_FILE" ]; then
          echo "üìä Analysis Configuration:"
          cat "$METADATA_FILE" | jq .
        fi
        
        # Verify token and test Copilot
        if [ -z "$GITHUB_TOKEN" ]; then
          echo "‚ùå ERROR: GITHUB_TOKEN not set!"
          exit 1
        fi
        
        # Quick Copilot test
        echo "üß™ Testing Copilot connectivity..."
        TEST_RESULT=$(echo "Respond with 'READY'" | timeout 10 copilot 2>&1)
        if [ $? -ne 0 ]; then
          echo "‚ùå ERROR: Copilot test failed: $TEST_RESULT"
          exit 1
        fi
        echo "‚úÖ Copilot connectivity confirmed"
        
        # Initialize comprehensive report
        echo "# üìã AI-Powered Backlog Analysis Report" > $(Agent.TempDirectory)/analysis-report.md
        echo "" >> $(Agent.TempDirectory)/analysis-report.md
        echo "**Generated:** $(date '+%Y-%m-%d %H:%M:%S UTC')" >> $(Agent.TempDirectory)/analysis-report.md
        echo "**Project:** ${{ parameters.projectName }}" >> $(Agent.TempDirectory)/analysis-report.md
        echo "**Analysis Mode:** ${{ parameters.analysisMode }}" >> $(Agent.TempDirectory)/analysis-report.md
        echo "**Pipeline Run:** $(Build.BuildId)" >> $(Agent.TempDirectory)/analysis-report.md
        echo "**Items Analyzed:** ${{ parameters.analyzeTop }}" >> $(Agent.TempDirectory)/analysis-report.md
        echo "" >> $(Agent.TempDirectory)/analysis-report.md
        echo "---" >> $(Agent.TempDirectory)/analysis-report.md
        echo "" >> $(Agent.TempDirectory)/analysis-report.md
        
        # Build analysis prompt based on mode
        case "${{ parameters.analysisMode }}" in
          "basic")
            ANALYSIS_PROMPT="Briefly analyze this work item for quality (1-10 score) and list 2 key issues:"
            ;;
          "standard")
            ANALYSIS_PROMPT="Analyze this work item using INVEST principles. Provide: 1) Overall score (1-10), 2) INVEST compliance, 3) Top 3 issues, 4) One key recommendation:"
            ;;
          "detailed")
            ANALYSIS_PROMPT="Comprehensive analysis of this work item. Provide: 1) Quality score (1-10), 2) INVEST principle breakdown, 3) Detailed issues list, 4) Specific recommendations, 5) Risk assessment:"
            ;;
          "governance")
            ANALYSIS_PROMPT="Governance and compliance analysis. Evaluate: 1) Quality score (1-10), 2) Risk level (Low/Medium/High), 3) Compliance issues, 4) Required actions, 5) Stakeholder impact:"
            ;;
          *)
            ANALYSIS_PROMPT="Analyze this work item for quality and provide improvement recommendations:"
            ;;
        esac
        
        echo "üéØ Using analysis mode: ${{ parameters.analysisMode }}"
        echo "üìù Analysis prompt template: $ANALYSIS_PROMPT"
        
        # Process work items with enhanced error handling
        PROCESSED=0
        FAILED=0
        MAX_ITEMS=${{ parameters.analyzeTop }}
        WORKITEMS_FILE="$(Agent.TempDirectory)/workitems-data/workitems_detailed.json"
        
        if [ ! -f "$WORKITEMS_FILE" ]; then
          echo "‚ùå ERROR: Work items file not found!"
          exit 1
        fi
        
        TOTAL_AVAILABLE=$(cat "$WORKITEMS_FILE" | jq '.value | length')
        echo "üìä Processing $TOTAL_AVAILABLE work items..."
        
        # Add summary section to report
        echo "## üìä Executive Summary" >> $(Agent.TempDirectory)/analysis-report.md
        echo "" >> $(Agent.TempDirectory)/analysis-report.md
        echo "| Metric | Value |" >> $(Agent.TempDirectory)/analysis-report.md
        echo "|--------|--------|" >> $(Agent.TempDirectory)/analysis-report.md
        echo "| Total Items Available | $TOTAL_AVAILABLE |" >> $(Agent.TempDirectory)/analysis-report.md
        echo "| Items Analyzed | Processing... |" >> $(Agent.TempDirectory)/analysis-report.md
        echo "| Analysis Mode | ${{ parameters.analysisMode }} |" >> $(Agent.TempDirectory)/analysis-report.md
        echo "" >> $(Agent.TempDirectory)/analysis-report.md
        echo "---" >> $(Agent.TempDirectory)/analysis-report.md
        echo "" >> $(Agent.TempDirectory)/analysis-report.md
        echo "## üìù Detailed Work Item Analysis" >> $(Agent.TempDirectory)/analysis-report.md
        echo "" >> $(Agent.TempDirectory)/analysis-report.md
        
        # Enhanced processing loop with progress tracking
        for i in $(seq 0 $((MAX_ITEMS - 1))); do
          # Get work item at index i
          ITEM=$(cat "$WORKITEMS_FILE" | jq -c ".value[$i]")
          
          if [ "$ITEM" = "null" ] || [ -z "$ITEM" ]; then
            echo "‚ÑπÔ∏è No more items to process (processed: $PROCESSED)"
            break
          fi
          
          # Extract and sanitize fields
          WI_ID=$(echo "$ITEM" | jq -r '.id')
          WI_TITLE=$(echo "$ITEM" | jq -r '.fields."System.Title" // "Untitled"' | sed 's/["`\r\n]/ /g' | head -c 100)
          WI_TYPE=$(echo "$ITEM" | jq -r '.fields."System.WorkItemType" // "Unknown"')
          WI_STATE=$(echo "$ITEM" | jq -r '.fields."System.State" // "Unknown"')
          WI_PRIORITY=$(echo "$ITEM" | jq -r '.fields."Microsoft.VSTS.Common.Priority" // "0"')
          WI_DESC=$(echo "$ITEM" | jq -r '.fields."System.Description" // "No description"' | sed 's/<[^>]*>//g' | sed 's/["`\r\n]/ /g' | head -c 300)
          WI_AC=$(echo "$ITEM" | jq -r '.fields."Microsoft.VSTS.Common.AcceptanceCriteria" // "No acceptance criteria"' | sed 's/<[^>]*>//g' | sed 's/["`\r\n]/ /g' | head -c 200)
          
          echo ""
          echo "üîç Processing Work Item #$WI_ID ($((i + 1))/$MAX_ITEMS)"
          echo "   Title: $WI_TITLE"
          echo "   Type: $WI_TYPE | State: $WI_STATE | Priority: $WI_PRIORITY"
          
          # Build comprehensive prompt
          FULL_PROMPT="$ANALYSIS_PROMPT
          
Work Item Details:
- ID: $WI_ID
- Title: $WI_TITLE  
- Type: $WI_TYPE
- State: $WI_STATE
- Priority: $WI_PRIORITY
- Description: $WI_DESC
- Acceptance Criteria: $WI_AC

Please analyze this work item and provide structured feedback."
          
          # Call Copilot with enhanced error handling
          echo "ü§ñ Analyzing with Copilot..."
          ANALYSIS=$(echo "$FULL_PROMPT" | timeout $(COPILOT_TIMEOUT) copilot 2>&1)
          COPILOT_EXIT=$?
          
          case $COPILOT_EXIT in
            0)
              echo "‚úÖ Analysis complete for #$WI_ID"
              PROCESSED=$((PROCESSED + 1))
              ;;
            124)
              echo "‚è∞ Timeout for #$WI_ID (${COPILOT_TIMEOUT}s)"
              ANALYSIS="‚è∞ Analysis timed out - work item may be too complex or Copilot service is slow."
              FAILED=$((FAILED + 1))
              ;;
            *)
              echo "‚ùå Analysis failed for #$WI_ID (exit: $COPILOT_EXIT)"
              ANALYSIS="‚ùå Analysis failed due to service error. Please retry or check Copilot service status."
              FAILED=$((FAILED + 1))
              ;;
          esac
          
          # Add comprehensive results to report
          echo "### üéØ Work Item #${WI_ID}: ${WI_TITLE}" >> $(Agent.TempDirectory)/analysis-report.md
          echo "" >> $(Agent.TempDirectory)/analysis-report.md
          echo "**Type:** ${WI_TYPE} | **State:** ${WI_STATE} | **Priority:** ${WI_PRIORITY}" >> $(Agent.TempDirectory)/analysis-report.md
          echo "" >> $(Agent.TempDirectory)/analysis-report.md
          echo "**Description:** ${WI_DESC}" >> $(Agent.TempDirectory)/analysis-report.md
          echo "" >> $(Agent.TempDirectory)/analysis-report.md
          echo "**Acceptance Criteria:** ${WI_AC}" >> $(Agent.TempDirectory)/analysis-report.md
          echo "" >> $(Agent.TempDirectory)/analysis-report.md
          echo "**ü§ñ AI Analysis:**" >> $(Agent.TempDirectory)/analysis-report.md
          echo "" >> $(Agent.TempDirectory)/analysis-report.md
          echo "${ANALYSIS}" >> $(Agent.TempDirectory)/analysis-report.md
          echo "" >> $(Agent.TempDirectory)/analysis-report.md
          echo "---" >> $(Agent.TempDirectory)/analysis-report.md
          echo "" >> $(Agent.TempDirectory)/analysis-report.md
          
          # Progress indicator
          PROGRESS=$(echo "scale=1; ($i + 1) * 100 / $MAX_ITEMS" | bc -l 2>/dev/null || echo "N/A")
          echo "üìà Progress: $((i + 1))/$MAX_ITEMS items ($PROGRESS%)"
        done
        
        # Update summary in report
        echo "‚úÖ Analysis complete!"
        echo "üìä Final Statistics:"
        echo "   - Processed: $PROCESSED items"
        echo "   - Failed: $FAILED items"
        echo "   - Success Rate: $(echo "scale=1; $PROCESSED * 100 / ($PROCESSED + $FAILED)" | bc -l 2>/dev/null || echo "N/A")%"
        
        # Generate executive summary if requested
        if [ "${{ parameters.generateExecutiveSummary }}" = "true" ]; then
          echo ""
          echo "üìã Generating executive summary..."
          
          SUMMARY_PROMPT="Based on the analysis of $PROCESSED work items from ${{ parameters.projectName }}, create a brief executive summary focusing on: 1) Overall backlog quality, 2) Top 3 issues found, 3) Key recommendations for improvement, 4) Risk assessment. Keep it concise and actionable for stakeholders."
          
          EXECUTIVE_SUMMARY=$(echo "$SUMMARY_PROMPT" | timeout 60 copilot 2>&1)
          
          if [ $? -eq 0 ]; then
            echo "## üéØ Executive Summary" > $(Agent.TempDirectory)/executive-summary.md
            echo "" >> $(Agent.TempDirectory)/executive-summary.md
            echo "$EXECUTIVE_SUMMARY" >> $(Agent.TempDirectory)/executive-summary.md
            echo "‚úÖ Executive summary generated"
          else
            echo "‚ö†Ô∏è Executive summary generation failed"
          fi
        fi
        
        # Validate we processed at least one item
        if [ $PROCESSED -eq 0 ]; then
          echo "‚ùå ERROR: No items were successfully processed!"
          exit 1
        fi
        
        echo "üéâ Analysis pipeline completed successfully!"
        
      displayName: 'Advanced AI Analysis'
      env:
        GITHUB_TOKEN: $(GITHUB_TOKEN)
        GH_TOKEN: $(GITHUB_TOKEN)
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Analysis Report'
      inputs:
        pathToPublish: '$(Agent.TempDirectory)/analysis-report.md'
        artifactName: 'copilot-analysis-report'
      condition: always()
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Executive Summary'
      inputs:
        pathToPublish: '$(Agent.TempDirectory)/executive-summary.md'
        artifactName: 'executive-summary'
      condition: and(always(), eq('${{ parameters.generateExecutiveSummary }}', 'true'))

- stage: GenerateResults
  displayName: 'Generate Final Results & Notifications'
  dependsOn: AnalyzeWithCopilot
  condition: succeededOrFailed()
  jobs:
  - job: CreateFinalReport
    displayName: 'Create Comprehensive Report'
    steps:
    
    - task: DownloadBuildArtifacts@0
      displayName: 'Download All Artifacts'
      inputs:
        downloadType: 'specific'
        downloadPath: '$(Agent.TempDirectory)'
      continueOnError: true
    
    - script: |
        echo "üìä GENERATING COMPREHENSIVE RESULTS"
        echo "=================================="
        echo ""
        echo "üéØ Pipeline Execution Summary"
        echo "Pipeline Run: $(Build.BuildId)"
        echo "Timestamp: $(ANALYSIS_TIMESTAMP)"
        echo "Project: ${{ parameters.projectName }}"
        echo "Analysis Mode: ${{ parameters.analysisMode }}"
        echo "Items Requested: ${{ parameters.analyzeTop }}"
        echo ""
        
        # Check available artifacts
        echo "üìÅ Available Artifacts:"
        find $(Agent.TempDirectory) -name "*.md" -o -name "*.json" | head -10
        echo ""
        
        # Display analysis report preview if available
        ANALYSIS_REPORT="$(Agent.TempDirectory)/copilot-analysis-report/analysis-report.md"
        if [ -f "$ANALYSIS_REPORT" ]; then
          echo "‚úÖ Analysis Report Generated Successfully"
          echo ""
          echo "üìÑ Report Preview (first 50 lines):"
          echo "===================================="
          head -50 "$ANALYSIS_REPORT"
          echo ""
          echo "üìä Report Statistics:"
          echo "   Total Lines: $(wc -l < "$ANALYSIS_REPORT")"
          echo "   File Size: $(du -h "$ANALYSIS_REPORT" | cut -f1)"
        else
          echo "‚ö†Ô∏è Analysis report not found at expected location"
          echo "üîç Searching for analysis files..."
          find $(Agent.TempDirectory) -name "*analysis*" -type f
        fi
        
        # Display executive summary if available
        EXEC_SUMMARY="$(Agent.TempDirectory)/executive-summary/executive-summary.md"
        if [ -f "$EXEC_SUMMARY" ]; then
          echo ""
          echo "üìà Executive Summary Generated"
          echo "=============================="
          cat "$EXEC_SUMMARY"
        fi
        
        # Display metadata if available
        METADATA_FILE="$(Agent.TempDirectory)/workitems-data/metadata.json"
        if [ -f "$METADATA_FILE" ]; then
          echo ""
          echo "üìã Analysis Metadata:"
          echo "===================="
          cat "$METADATA_FILE" | jq .
        fi
        
        echo ""
        echo "üéâ ANALYSIS PIPELINE COMPLETED"
        echo "=============================="
        echo "‚úÖ Backlog analysis finished successfully"
        echo "üìä Results available in pipeline artifacts"
        echo "üîó Download artifacts to view detailed analysis"
        
        # Performance metrics
        echo ""
        echo "‚ö° Performance Metrics:"
        echo "   Pipeline Duration: $AGENT_JOBSTATUS seconds"
        echo "   Analysis Mode: ${{ parameters.analysisMode }}"
        echo "   Success: $([ -f "$ANALYSIS_REPORT" ] && echo "‚úÖ Yes" || echo "‚ùå No")"
        
      displayName: 'Generate Final Summary'
    
    - script: |
        # Send notifications if enabled
        if [ "${{ parameters.enableNotifications }}" = "true" ]; then
          echo "üì¢ SENDING NOTIFICATIONS"
          echo "======================="
          
          # Teams notification (if webhook configured)
          if [ -n "$(TEAMS_WEBHOOK)" ]; then
            echo "üì® Sending Teams notification..."
            
            TEAMS_PAYLOAD="{
              \"@type\": \"MessageCard\",
              \"summary\": \"Backlog Analysis Complete\",
              \"title\": \"ü§ñ AI Backlog Analysis Results\",
              \"text\": \"Analysis completed for ${{ parameters.projectName }}\",
              \"sections\": [{
                \"facts\": [
                  {\"name\": \"Project\", \"value\": \"${{ parameters.projectName }}\"},
                  {\"name\": \"Items Analyzed\", \"value\": \"${{ parameters.analyzeTop }}\"},
                  {\"name\": \"Analysis Mode\", \"value\": \"${{ parameters.analysisMode }}\"},
                  {\"name\": \"Pipeline Run\", \"value\": \"$(Build.BuildId)\"},
                  {\"name\": \"Timestamp\", \"value\": \"$(ANALYSIS_TIMESTAMP)\"}
                ]
              }],
              \"potentialAction\": [{
                \"@type\": \"OpenUri\",
                \"name\": \"View Results\",
                \"targets\": [{
                  \"os\": \"default\",
                  \"uri\": \"$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)\"
                }]
              }]
            }"
            
            curl -H "Content-Type: application/json" -d "$TEAMS_PAYLOAD" "$(TEAMS_WEBHOOK)" || echo "‚ö†Ô∏è Teams notification failed"
          fi
          
          echo "‚úÖ Notifications sent"
        else
          echo "üì¢ Notifications disabled (enableNotifications: false)"
        fi
        
      displayName: 'Send Notifications'
      env:
        TEAMS_WEBHOOK: $(TEAMS_WEBHOOK)
        SLACK_WEBHOOK: $(SLACK_WEBHOOK)
      condition: always()
      continueOnError: true