# ‚ö° Reusable Template: Fetch Azure DevOps Data
# Query and retrieve work items with configurable parameters

parameters:
  - name: projectName
    type: string
  - name: workItemTypes
    type: string
    default: 'Product Backlog Item'
  - name: maxItems
    type: number
    default: 20
  - name: queryType
    type: string
    default: 'backlog'
    values:
      - 'backlog'     # Active backlog items
      - 'sprint'      # Current sprint items  
      - 'recent'      # Recently updated items
      - 'custom'      # Custom WIQL query
  - name: customQuery
    type: string
    default: ''

steps:
- script: |
    echo "üìä Fetching Azure DevOps Data (Template v1.0)"
    echo "Project: ${{ parameters.projectName }}"
    echo "Query Type: ${{ parameters.queryType }}"
    echo "Max Items: ${{ parameters.maxItems }}"
    
    # Process work item types parameter (convert comma-separated to WIQL format)
    WORK_ITEM_TYPES="${{ parameters.workItemTypes }}"
    # Convert "Type1,Type2" to "'Type1','Type2'"
    FORMATTED_TYPES=$(echo "$WORK_ITEM_TYPES" | sed "s/,/','/g" | sed "s/^/'/" | sed "s/$/'/")
    echo "üìù Work Item Types: $FORMATTED_TYPES"
    
    # Build WIQL query based on type
    case "${{ parameters.queryType }}" in
      "backlog")
        WIQL_QUERY="SELECT [System.Id] FROM workitems WHERE [System.WorkItemType] IN ($FORMATTED_TYPES) AND [System.State] IN ('New', 'In Progress', 'To Do') ORDER BY [Microsoft.VSTS.Common.Priority] ASC, [System.CreatedDate] DESC"
        ;;
      "sprint")
        WIQL_QUERY="SELECT [System.Id] FROM workitems WHERE [System.WorkItemType] IN ($FORMATTED_TYPES) AND [System.IterationPath] = @currentIteration ORDER BY [System.State] ASC"
        ;;
      "recent")
        WIQL_QUERY="SELECT [System.Id] FROM workitems WHERE [System.WorkItemType] IN ($FORMATTED_TYPES) AND [System.ChangedDate] >= @today - 30 ORDER BY [System.ChangedDate] DESC"
        ;;
      "custom")
        WIQL_QUERY="${{ parameters.customQuery }}"
        ;;
    esac
    
    echo "üîç WIQL Query: $WIQL_QUERY"
    
    # API call function with retry
    call_api_with_retry() {
      local url="$1"
      local output_file="$2"
      local max_attempts=3
      local attempt=1
      
      while [ $attempt -le $max_attempts ]; do
        echo "üìû API call attempt $attempt/$max_attempts"
        
        if curl -s -H "Authorization: Bearer $(System.AccessToken)" \
           --connect-timeout 30 --max-time 30 "$url" > "$output_file.tmp"; then
          
          if jq empty "$output_file.tmp" 2>/dev/null; then
            mv "$output_file.tmp" "$output_file"
            echo "‚úÖ API call successful"
            return 0
          else
            echo "‚ùå Invalid JSON response"
          fi
        else
          echo "‚ùå API call failed"
        fi
        
        if [ $attempt -eq $max_attempts ]; then
          echo "üí• All API attempts failed"
          return 1
        fi
        
        sleep 5
        attempt=$((attempt + 1))
      done
    }
    
    # Execute WIQL query
    PROJECT_NAME_ENCODED="${{ replace(parameters.projectName, ' ', '%20') }}"
    WIQL_URL="$(System.CollectionUri)${PROJECT_NAME_ENCODED}/_apis/wit/wiql?api-version=7.0"
    
    # Create output directory early
    mkdir -p $(Agent.TempDirectory)/workitems-data
    
    # Create query payload
    echo "{\"query\": \"$WIQL_QUERY\"}" > query_payload.json
    
    # Debug: Let's see what work item types and states actually exist
    echo "üîç Debug: Checking actual work item types and states in project..."
    DEBUG_QUERY="SELECT [System.Id] FROM workitems WHERE [System.TeamProject] = '${{ parameters.projectName }}'"
    echo "{\"query\": \"$DEBUG_QUERY\"}" > debug_query.json
    
    echo "üìû Debug API call..."
    if curl -s -H "Authorization: Bearer $(System.AccessToken)" \
       --connect-timeout 30 --max-time 30 \
       "$(System.CollectionUri)${PROJECT_NAME_ENCODED}/_apis/wit/wiql?api-version=7.0" \
       -d @debug_query.json -H "Content-Type: application/json" > debug_results.json; then
      
      # Get the IDs and then fetch the actual work items with their fields
      DEBUG_IDS=$(cat debug_results.json | jq -r '.workItems[:10] | map(.id) | join(",")' 2>/dev/null)
      
      if [ ! -z "$DEBUG_IDS" ] && [ "$DEBUG_IDS" != "null" ]; then
        echo "üìã Found work item IDs: $DEBUG_IDS"
        
        # Fetch the actual work items with their fields
        DEBUG_DETAILS_URL="$(System.CollectionUri)${PROJECT_NAME_ENCODED}/_apis/wit/workitems?ids=${DEBUG_IDS}&\$expand=all&api-version=7.0"
        
        if curl -s -H "Authorization: Bearer $(System.AccessToken)" \
           --connect-timeout 30 --max-time 30 "$DEBUG_DETAILS_URL" > debug_details.json; then
          
          echo "üìã Available Work Item Types in project:"
          cat debug_details.json | jq -r '.value[]?.fields."System.WorkItemType"' 2>/dev/null | sort | uniq || echo "No types found"
          
          echo "üìã Available States in project:"  
          cat debug_details.json | jq -r '.value[]?.fields."System.State"' 2>/dev/null | sort | uniq || echo "No states found"
          
          echo "üìã Work Item Type + State combinations:"
          cat debug_details.json | jq -r '.value[]? | "\(.fields."System.WorkItemType") - \(.fields."System.State")"' 2>/dev/null | sort | uniq || echo "No combinations found"
        else
          echo "‚ùå Failed to fetch work item details for debug"
        fi
      else
        echo "‚ö†Ô∏è No work items found in project for debugging"
      fi
    else
      echo "‚ùå Debug query failed"
    fi
    echo ""
    
    if curl -s -H "Authorization: Bearer $(System.AccessToken)" \
       --connect-timeout 30 --max-time 30 \
       "$(System.CollectionUri)${PROJECT_NAME_ENCODED}/_apis/wit/wiql?api-version=7.0" \
       -d @query_payload.json -H "Content-Type: application/json" > workitem_ids.json; then
      TOTAL_ITEMS=$(cat workitem_ids.json | jq '.workItems | length')
      echo "üìã Found $TOTAL_ITEMS work items"
      
      # Debug: Let's see what the actual query response looks like
      echo "üîç Debug: Main query response:"
      cat workitem_ids.json | jq . 2>/dev/null || echo "Failed to parse JSON"
      
      # Debug: Let's try a simpler query to see if we can find the specific item
      echo "üîç Debug: Testing simpler query for Product Backlog Item with New state..."
      SIMPLE_QUERY="SELECT [System.Id] FROM workitems WHERE [System.WorkItemType] = 'Product Backlog Item' AND [System.State] = 'New'"
      echo "{\"query\": \"$SIMPLE_QUERY\"}" > simple_query.json
      
      if curl -s -H "Authorization: Bearer $(System.AccessToken)" \
         --connect-timeout 30 --max-time 30 \
         "$(System.CollectionUri)${PROJECT_NAME_ENCODED}/_apis/wit/wiql?api-version=7.0" \
         -d @simple_query.json -H "Content-Type: application/json" > simple_results.json; then
        
        SIMPLE_ITEMS=$(cat simple_results.json | jq '.workItems | length')
        echo "üìã Simple query found: $SIMPLE_ITEMS items"
        cat simple_results.json | jq . 2>/dev/null || echo "Failed to parse simple query JSON"
      else
        echo "‚ùå Simple query failed"
      fi
      
      if [ "$TOTAL_ITEMS" -gt 0 ]; then
        # Get limited set based on maxItems
        ITEMS_TO_FETCH=$([ "$TOTAL_ITEMS" -lt ${{ parameters.maxItems }} ] && echo "$TOTAL_ITEMS" || echo "${{ parameters.maxItems }}")
        IDS=$(cat workitem_ids.json | jq -r ".workItems[:$ITEMS_TO_FETCH] | map(.id) | join(\",\")")
        
        # Fetch detailed work items
        DETAILS_URL="$(System.CollectionUri)${PROJECT_NAME_ENCODED}/_apis/wit/workitems?ids=${IDS}&\$expand=all&api-version=7.0"
        
        if call_api_with_retry "$DETAILS_URL" "workitems_detailed.json"; then
          echo "‚úÖ Successfully fetched $ITEMS_TO_FETCH work items"
          cp workitems_detailed.json $(Agent.TempDirectory)/workitems-data/
        else
          echo "‚ùå Failed to fetch work item details"
          exit 1
        fi
      else
        echo "‚ö†Ô∏è No work items found - creating empty result set"
        echo '{"value": []}' > $(Agent.TempDirectory)/workitems-data/workitems_detailed.json
      fi
      
      # Create metadata (always, even for empty results)
      echo "{" > $(Agent.TempDirectory)/workitems-data/metadata.json
      echo "  \"query_type\": \"${{ parameters.queryType }}\"," >> $(Agent.TempDirectory)/workitems-data/metadata.json
      echo "  \"project\": \"${{ parameters.projectName }}\"," >> $(Agent.TempDirectory)/workitems-data/metadata.json
      echo "  \"total_available\": $TOTAL_ITEMS," >> $(Agent.TempDirectory)/workitems-data/metadata.json
      echo "  \"items_fetched\": ${ITEMS_TO_FETCH:-0}" >> $(Agent.TempDirectory)/workitems-data/metadata.json
      echo "}" >> $(Agent.TempDirectory)/workitems-data/metadata.json
      
    else
      echo "‚ùå Failed to execute WIQL query"
      exit 1
    fi
    
  displayName: 'Fetch Work Items'
  env:
    SYSTEM_ACCESSTOKEN: $(System.AccessToken)

- task: PublishBuildArtifacts@1
  displayName: 'Publish Work Items Data'
  inputs:
    pathToPublish: '$(Agent.TempDirectory)/workitems-data'
    artifactName: 'workitems-data'
