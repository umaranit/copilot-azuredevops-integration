# Azure Pipeline Template: Fetch Azure DevOps Work Items
# Reusable component for querying and retrieving work items

parameters:
  - name: azureDevOpsOrganization
    displayName: 'Azure DevOps Organization'
    type: string
  
  - name: projectName
    displayName: 'Project Name'
    type: string
  
  - name: wiqlQuery
    displayName: 'WIQL Query'
    type: string
    default: "SELECT [System.Id], [System.Title], [System.State], [System.AssignedTo], [System.Tags] FROM WorkItems WHERE [System.TeamProject] = '@project' AND [System.State] <> 'Closed' ORDER BY [System.ChangedDate] DESC"
  
  - name: maxResults
    displayName: 'Maximum Results'
    type: number
    default: 100
  
  - name: includeDetails
    displayName: 'Include Work Item Details'
    type: boolean
    default: true
  
  - name: outputFormat
    displayName: 'Output Format'
    type: string
    default: 'detailed'
    values:
      - 'basic'     # ID, Title, State only
      - 'standard'  # Common fields
      - 'detailed'  # All available fields
  
  - name: retryAttempts
    displayName: 'Retry Attempts'
    type: number
    default: 3

stages:
- stage: FetchWorkItems
  displayName: 'Fetch Azure DevOps Work Items'
  jobs:
  - job: QueryAndRetrieve
    displayName: 'Query & Retrieve Work Items'
    variables:
      ADO_ORGANIZATION: ${{ parameters.azureDevOpsOrganization }}
      PROJECT_NAME: ${{ parameters.projectName }}
      WIQL_QUERY: ${{ parameters.wiqlQuery }}
      MAX_RESULTS: ${{ parameters.maxResults }}
      INCLUDE_DETAILS: ${{ parameters.includeDetails }}
      OUTPUT_FORMAT: ${{ parameters.outputFormat }}
      RETRY_ATTEMPTS: ${{ parameters.retryAttempts }}
    
    steps:
    - script: |
        echo "üìä WORK ITEMS FETCH TEMPLATE v1.0"
        echo "================================="
        echo "Organization: $(ADO_ORGANIZATION)"
        echo "Project: $(PROJECT_NAME)"
        echo "Max Results: $(MAX_RESULTS)"
        echo "Include Details: $(INCLUDE_DETAILS)"
        echo "Output Format: $(OUTPUT_FORMAT)"
        echo "Retry Attempts: $(RETRY_ATTEMPTS)"
        echo ""
        
        # Validate required parameters
        if [ -z "$(ADO_ORGANIZATION)" ]; then
          echo "‚ùå ERROR: Azure DevOps Organization is required"
          exit 1
        fi
        
        if [ -z "$(PROJECT_NAME)" ]; then
          echo "‚ùå ERROR: Project Name is required"
          exit 1
        fi
        
        # Validate max results
        if [ $(MAX_RESULTS) -lt 1 ] || [ $(MAX_RESULTS) -gt 1000 ]; then
          echo "‚ùå ERROR: Max Results must be between 1 and 1000"
          exit 1
        fi
        
        echo "‚úÖ Parameter validation passed"
        
      displayName: 'Validate Template Parameters'
    
    - script: |
        echo "üîß PREPARING WIQL QUERY"
        echo "======================"
        
        # Replace project placeholder in WIQL query
        PROCESSED_QUERY=$(echo '$(WIQL_QUERY)' | sed "s/@project/$(PROJECT_NAME)/g")
        
        echo "üìù Original Query Template:"
        echo "$(WIQL_QUERY)"
        echo ""
        echo "üìù Processed Query:"
        echo "$PROCESSED_QUERY"
        
        # Validate WIQL syntax basics
        if ! echo "$PROCESSED_QUERY" | grep -i "SELECT.*FROM.*WorkItems" > /dev/null; then
          echo "‚ö†Ô∏è WARNING: WIQL query may have invalid syntax"
          echo "Expected pattern: SELECT ... FROM WorkItems ..."
        else
          echo "‚úÖ WIQL query syntax validation passed"
        fi
        
        # Save processed query for next steps
        echo "$PROCESSED_QUERY" > processed_query.wiql
        echo "üíæ Processed query saved to processed_query.wiql"
        
      displayName: 'Process WIQL Query'
    
    - script: |
        echo "üîç EXECUTING WIQL QUERY"
        echo "======================"
        
        # Read processed query
        QUERY=$(cat processed_query.wiql)
        
        # Function for API calls with retry
        api_call_with_retry() {
          local url="$1"
          local description="$2"
          local output_file="$3"
          local max_attempts=$(RETRY_ATTEMPTS)
          local attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "üîÑ Attempt $attempt/$max_attempts: $description"
            
            local response
            response=$(curl -s -w "\n%{http_code}" \
              -u ":$(AZURE_DEVOPS_EXT_PAT)" \
              -H "Content-Type: application/json" \
              -X POST \
              -d "{\"query\": \"$QUERY\"}" \
              "$url" 2>&1)
            
            local http_code=$(echo "$response" | tail -n1)
            local body=$(echo "$response" | head -n -1)
            
            case "$http_code" in
              200)
                echo "‚úÖ $description succeeded on attempt $attempt"
                echo "$body" > "$output_file"
                return 0
                ;;
              401)
                echo "‚ùå Authentication failed - check AZURE_DEVOPS_EXT_PAT token"
                echo "Response: $body"
                return 1
                ;;
              403)
                echo "‚ùå Access denied - check project permissions"
                echo "Response: $body"
                return 1
                ;;
              404)
                echo "‚ùå Project or organization not found"
                echo "Response: $body"
                return 1
                ;;
              *)
                echo "‚ùå $description failed with HTTP $http_code on attempt $attempt"
                echo "Response: $body"
                if [ $attempt -eq $max_attempts ]; then
                  echo "üí• $description failed after $max_attempts attempts"
                  return 1
                fi
                echo "‚è≥ Waiting 10 seconds before retry..."
                sleep 10
                attempt=$((attempt + 1))
                ;;
            esac
          done
        }
        
        # Execute WIQL query
        WIQL_URL="https://dev.azure.com/$(ADO_ORGANIZATION)/$(PROJECT_NAME)/_apis/wit/wiql?api-version=7.1-preview.2"
        
        echo "üåê Querying: $WIQL_URL"
        echo "üìã Query: $QUERY"
        
        api_call_with_retry "$WIQL_URL" "WIQL query execution" "wiql_response.json"
        
        # Parse and validate query results
        WORK_ITEM_COUNT=$(jq -r '.workItems | length' wiql_response.json 2>/dev/null || echo "0")
        
        if [ "$WORK_ITEM_COUNT" = "null" ] || [ "$WORK_ITEM_COUNT" = "0" ]; then
          echo "‚ö†Ô∏è No work items found matching the query"
          echo "üìä Query Results Summary:"
          echo "   - Work Items Found: 0"
          echo "   - This may be normal if no items match the criteria"
          
          # Create empty results file for consistency
          echo '{"workItems": [], "fields": [], "metadata": {"count": 0, "query": "'"$QUERY"'"}}' > work_items_basic.json
          
          echo "‚úÖ Empty results file created for downstream processing"
          return 0
        fi
        
        echo "üìä Query Results Summary:"
        echo "   - Work Items Found: $WORK_ITEM_COUNT"
        echo "   - Max Results Limit: $(MAX_RESULTS)"
        
        # Apply max results limit
        if [ "$WORK_ITEM_COUNT" -gt $(MAX_RESULTS) ]; then
          echo "‚ö†Ô∏è Results exceed limit, truncating to $(MAX_RESULTS) items"
          jq --argjson max $(MAX_RESULTS) '.workItems = .workItems[:$max]' wiql_response.json > wiql_response_limited.json
          mv wiql_response_limited.json wiql_response.json
          WORK_ITEM_COUNT=$(MAX_RESULTS)
        fi
        
        # Extract work item IDs for detailed fetch
        jq -r '.workItems[].id' wiql_response.json > work_item_ids.txt
        
        echo "üíæ Work item IDs saved to work_item_ids.txt"
        echo "‚úÖ WIQL query execution completed successfully"
        
      displayName: 'Execute WIQL Query'
      env:
        AZURE_DEVOPS_EXT_PAT: $(AZURE_DEVOPS_EXT_PAT)
    
    - script: |
        echo "üìã FETCHING WORK ITEM DETAILS"
        echo "============================="
        
        # Skip detailed fetch if not requested or no items found
        if [ "$(INCLUDE_DETAILS)" != "True" ]; then
          echo "‚ÑπÔ∏è Skipping detailed fetch (INCLUDE_DETAILS=False)"
          cp wiql_response.json work_items_basic.json
          exit 0
        fi
        
        if [ ! -s work_item_ids.txt ]; then
          echo "‚ÑπÔ∏è No work items to fetch details for"
          cp wiql_response.json work_items_basic.json
          exit 0
        fi
        
        WORK_ITEM_COUNT=$(wc -l < work_item_ids.txt)
        echo "üéØ Fetching details for $WORK_ITEM_COUNT work items"
        
        # Define field sets based on output format
        case "$(OUTPUT_FORMAT)" in
          "basic")
            FIELDS="System.Id,System.Title,System.State"
            ;;
          "standard")
            FIELDS="System.Id,System.Title,System.State,System.AssignedTo,System.CreatedDate,System.ChangedDate,System.WorkItemType,System.Tags,System.AreaPath,System.IterationPath"
            ;;
          "detailed")
            FIELDS="System.Id,System.Title,System.Description,System.State,System.AssignedTo,System.CreatedBy,System.CreatedDate,System.ChangedBy,System.ChangedDate,System.WorkItemType,System.Tags,System.AreaPath,System.IterationPath,Microsoft.VSTS.Common.Priority,Microsoft.VSTS.Common.Severity,Microsoft.VSTS.Common.AcceptanceCriteria,Microsoft.VSTS.Scheduling.Effort,Microsoft.VSTS.Scheduling.StoryPoints"
            ;;
        esac
        
        echo "üìä Output Format: $(OUTPUT_FORMAT)"
        echo "üìã Fields: $FIELDS"
        
        # Batch work item IDs for efficient API calls (max 200 per batch)
        BATCH_SIZE=200
        BATCH_COUNT=0
        
        # Initialize results array
        echo '[]' > work_items_detailed.json
        
        # Process work items in batches
        while IFS= read -r batch_ids; do
          if [ -z "$batch_ids" ]; then continue; fi
          
          BATCH_COUNT=$((BATCH_COUNT + 1))
          echo "üì¶ Processing batch $BATCH_COUNT..."
          
          # Build batch URL
          BATCH_URL="https://dev.azure.com/$(ADO_ORGANIZATION)/$(PROJECT_NAME)/_apis/wit/workitems?ids=$batch_ids&fields=$FIELDS&api-version=7.1-preview.3"
          
          # Function for batch API call with retry
          batch_api_call() {
            local max_attempts=$(RETRY_ATTEMPTS)
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "üîÑ Batch $BATCH_COUNT attempt $attempt/$max_attempts"
              
              local response
              response=$(curl -s -w "\n%{http_code}" \
                -u ":$(AZURE_DEVOPS_EXT_PAT)" \
                -H "Accept: application/json" \
                "$BATCH_URL" 2>&1)
              
              local http_code=$(echo "$response" | tail -n1)
              local body=$(echo "$response" | head -n -1)
              
              case "$http_code" in
                200)
                  echo "‚úÖ Batch $BATCH_COUNT succeeded on attempt $attempt"
                  echo "$body" > "batch_${BATCH_COUNT}.json"
                  
                  # Merge batch results
                  jq -s '.[0] + (.[1].value // [])' work_items_detailed.json "batch_${BATCH_COUNT}.json" > temp_merged.json
                  mv temp_merged.json work_items_detailed.json
                  
                  # Cleanup batch file
                  rm "batch_${BATCH_COUNT}.json"
                  return 0
                  ;;
                *)
                  echo "‚ùå Batch $BATCH_COUNT failed with HTTP $http_code on attempt $attempt"
                  echo "Response: $body"
                  if [ $attempt -eq $max_attempts ]; then
                    echo "üí• Batch $BATCH_COUNT failed after $max_attempts attempts"
                    return 1
                  fi
                  sleep 5
                  attempt=$((attempt + 1))
                  ;;
              esac
            done
          }
          
          batch_api_call || exit 1
          
          # Progress indicator
          PROCESSED_COUNT=$((BATCH_COUNT * BATCH_SIZE))
          if [ $PROCESSED_COUNT -gt $WORK_ITEM_COUNT ]; then
            PROCESSED_COUNT=$WORK_ITEM_COUNT
          fi
          echo "üìà Progress: $PROCESSED_COUNT/$WORK_ITEM_COUNT work items processed"
          
        done < <(
          # Create batches of work item IDs
          paste -sd, < work_item_ids.txt | \
          fold -w $(($BATCH_SIZE * 10)) | \
          sed 's/,\{200,\}/\n/g'
        )
        
        # Validate final results
        FETCHED_COUNT=$(jq '. | length' work_items_detailed.json)
        echo ""
        echo "üìä FETCH RESULTS SUMMARY"
        echo "========================"
        echo "Work Items Requested: $WORK_ITEM_COUNT"
        echo "Work Items Fetched: $FETCHED_COUNT"
        echo "Output Format: $(OUTPUT_FORMAT)"
        echo "Batches Processed: $BATCH_COUNT"
        
        if [ "$FETCHED_COUNT" -eq "$WORK_ITEM_COUNT" ]; then
          echo "‚úÖ All work items fetched successfully"
        else
          echo "‚ö†Ô∏è Partial fetch: $FETCHED_COUNT/$WORK_ITEM_COUNT"
        fi
        
        # Use detailed results as final output
        mv work_items_detailed.json work_items_basic.json
        
      displayName: 'Fetch Work Item Details'
      env:
        AZURE_DEVOPS_EXT_PAT: $(AZURE_DEVOPS_EXT_PAT)
    
    - script: |
        echo "üßπ CLEANING AND FORMATTING RESULTS"
        echo "=================================="
        
        # Validate JSON structure
        if ! jq empty work_items_basic.json 2>/dev/null; then
          echo "‚ùå ERROR: Invalid JSON in results file"
          exit 1
        fi
        
        # Add metadata to results
        FINAL_COUNT=$(jq '. | length' work_items_basic.json)
        QUERY=$(cat processed_query.wiql)
        
        jq --arg query "$QUERY" \
           --arg organization "$(ADO_ORGANIZATION)" \
           --arg project "$(PROJECT_NAME)" \
           --arg format "$(OUTPUT_FORMAT)" \
           --argjson count "$FINAL_COUNT" \
           --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
           '{
             metadata: {
               query: $query,
               organization: $organization,
               project: $project,
               outputFormat: $format,
               count: $count,
               timestamp: $timestamp,
               includeDetails: $(INCLUDE_DETAILS)
             },
             workItems: .
           }' work_items_basic.json > work_items_final.json
        
        # Generate human-readable summary
        echo "üìù Generating summary report..."
        
        cat > work_items_summary.txt << EOF
AZURE DEVOPS WORK ITEMS FETCH SUMMARY
====================================

Fetch Details:
- Organization: $(ADO_ORGANIZATION)
- Project: $(PROJECT_NAME)
- Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)
- Output Format: $(OUTPUT_FORMAT)
- Include Details: $(INCLUDE_DETAILS)

Query Executed:
$QUERY

Results:
- Total Work Items: $FINAL_COUNT
- Max Results Limit: $(MAX_RESULTS)

Work Items by State:
$(jq -r '.workItems[] | .fields["System.State"]' work_items_basic.json 2>/dev/null | sort | uniq -c | sort -nr || echo "State information not available")

Work Items by Type:
$(jq -r '.workItems[] | .fields["System.WorkItemType"]' work_items_basic.json 2>/dev/null | sort | uniq -c | sort -nr || echo "Type information not available")

Recent Work Items (Top 5):
$(jq -r '.workItems[:5] | .[] | "\(.id): \(.fields["System.Title"] // "No Title")"' work_items_basic.json 2>/dev/null || echo "Title information not available")

EOF
        
        echo "üìä FINAL RESULTS SUMMARY"
        echo "========================"
        echo "‚úÖ Work Items Retrieved: $FINAL_COUNT"
        echo "‚úÖ Results File: work_items_final.json"
        echo "‚úÖ Summary Report: work_items_summary.txt"
        echo "‚úÖ Ready for downstream analysis"
        
        # Validate file sizes
        FINAL_SIZE=$(wc -c < work_items_final.json)
        echo "üìÅ Final JSON Size: $FINAL_SIZE bytes"
        
        if [ $FINAL_SIZE -gt 10485760 ]; then  # 10MB
          echo "‚ö†Ô∏è WARNING: Large results file (>10MB) may impact performance"
        fi
        
      displayName: 'Clean and Format Results'
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Work Items Data'
      inputs:
        pathToPublish: 'work_items_final.json'
        artifactName: 'WorkItemsData'
        publishLocation: 'Container'
    
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Work Items Summary'
      inputs:
        pathToPublish: 'work_items_summary.txt'
        artifactName: 'WorkItemsSummary'
        publishLocation: 'Container'
    
    - script: |
        echo "üìã FETCH TEMPLATE COMPLETION SUMMARY"
        echo "===================================="
        echo "‚úÖ WIQL query executed successfully"
        echo "‚úÖ Work items fetched with $(OUTPUT_FORMAT) format"
        echo "‚úÖ Results cleaned and formatted"
        echo "‚úÖ Artifacts published for downstream use"
        echo ""
        echo "üîß Output Files:"
        echo "   - work_items_final.json (structured data)"
        echo "   - work_items_summary.txt (human readable)"
        echo ""
        echo "üí° Usage in downstream workflows:"
        echo "   - Download 'WorkItemsData' artifact"
        echo "   - Parse work_items_final.json for analysis"
        echo "   - Reference metadata for context"
        echo ""
        echo "üéØ This template can be reused across projects and organizations!"
        
      displayName: 'Fetch Complete - Data Ready for Analysis'